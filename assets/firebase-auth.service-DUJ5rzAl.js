import{l as a,bV as u,bW as l,bX as d,bY as g,bZ as w,b_ as s,b$ as p,c0 as f,c1 as m,c2 as A}from"./index-C_JkpTYA.js";class v{authState={user:null,isAuthenticated:!1,isLoading:!0,error:null};listeners=new Set;avatarCache=new Map;avatarCacheExpiry=new Map;AVATAR_CACHE_TTL=1e3*60*60;async cacheAvatarImage(t,e){try{const i=await(await fetch(t)).blob(),o=await new Promise(c=>{const h=new FileReader;h.onloadend=()=>c(h.result),h.readAsDataURL(i)}),n=Date.now();this.avatarCache.set(e,o),this.avatarCacheExpiry.set(e,n+this.AVATAR_CACHE_TTL),this.authState.user&&this.authState.user.uid===e&&(this.authState={...this.authState,user:{...this.authState.user,photoURL:o}},this.notifyListeners())}catch(r){a.warn("Failed to cache avatar image:",r);const i=Date.now();this.avatarCache.set(e,t),this.avatarCacheExpiry.set(e,i+this.AVATAR_CACHE_TTL)}}constructor(){this.initializeAuthListener()}initializeAuthListener(){u(s,t=>{this.authState={user:t?this.transformFirebaseUser(t):null,isAuthenticated:!!t,isLoading:!1,error:null},a.info("Auth state changed:",{isAuthenticated:this.authState.isAuthenticated,user:this.authState.user?.email}),this.notifyListeners()})}transformFirebaseUser(t){let e=t.photoURL;if(e){const r=Date.now(),i=t.uid,o=e;if(this.avatarCache.has(i)&&this.avatarCacheExpiry.has(i)){const n=this.avatarCacheExpiry.get(i);r<n?e=this.avatarCache.get(i):(e=this.avatarCache.get(i),this.cacheAvatarImage(o,i))}else this.cacheAvatarImage(o,i)}return{uid:t.uid,email:t.email,displayName:t.displayName,photoURL:e,emailVerified:t.emailVerified,isAnonymous:t.isAnonymous,metadata:{creationTime:t.metadata.creationTime||void 0,lastSignInTime:t.metadata.lastSignInTime||void 0},providerData:t.providerData.map(r=>({providerId:r.providerId,uid:r.uid,displayName:r.displayName,email:r.email,photoURL:r.photoURL}))}}getProvider(t){switch(t){case"google":{const e=new w;return e.addScope("email"),e.addScope("profile"),e}case"facebook":{const e=new g;return e.addScope("email"),e}case"twitter":return new d;case"github":{const e=new l;return e.addScope("user:email"),e}default:throw new Error(`Unsupported provider: ${String(t)}`)}}async signInWithPopup(t){try{this.authState.isLoading=!0,this.authState.error=null,this.notifyListeners();const e=this.getProvider(t);a.info(`🔍 Attempting sign in with ${t}`),a.info("Current domain:",window.location.hostname),a.info("Current origin:",window.location.origin),a.info("Firebase auth domain:",s.app.options.authDomain);const r=window.open("","_blank","width=1,height=1");r?(r.close(),a.info("✅ Popup test passed - browser allows popups")):a.warn("⚠️ Popup blocked by browser - this will cause auth to fail");const i=await p(s,e);return a.success(`Sign in successful with ${t}:`,i.user.email),i}catch(e){const r=e instanceof Error?e.message:"Sign in failed";if(this.authState.error=r,this.authState.isLoading=!1,this.notifyListeners(),a.error(`Sign in error with ${t}:`,e),e instanceof Error){const i=e;a.error("Error code:",i.code||"unknown"),a.error("Error message:",e.message),i.code==="auth/popup-closed-by-user"&&(a.warn("💡 Popup closed - this might indicate:"),a.warn("  1. User closed popup manually"),a.warn("  2. Popup blocked by browser"),a.warn("  3. OAuth configuration issue"),a.warn("  4. Domain not authorized in Firebase Console"))}throw e}}async signInWithRedirect(t){try{const e=this.getProvider(t);await f(s,e)}catch(e){throw a.error("Sign in with redirect error:",e),e}}async getRedirectResult(){try{return await m(s)}catch(t){throw a.error("Get redirect result error:",t),t}}async signOut(){try{await A(s),a.info("User signed out successfully")}catch(t){throw a.error("Sign out error:",t),t}}getAuthState(){return{...this.authState}}getCurrentUser(){return this.authState.user}isAuthenticated(){return this.authState.isAuthenticated}onAuthStateChange(t){return this.listeners.add(t),t(this.authState),()=>{this.listeners.delete(t)}}notifyListeners(){this.listeners.forEach(t=>t(this.authState))}hasPermission(){return this.authState.user?Promise.resolve(this.authState.isAuthenticated):Promise.resolve(!1)}async isEditor(){return this.hasPermission()}async getAccessToken(){if(!s.currentUser)return null;try{return await s.currentUser.getIdToken()}catch(t){return a.error("Error getting access token:",t),null}}clearAvatarCache(){this.avatarCache.clear(),this.avatarCacheExpiry.clear(),a.info("Avatar cache cleared")}getCachedAvatarUrl(t){const e=Date.now();if(this.avatarCache.has(t)&&this.avatarCacheExpiry.has(t)){const r=this.avatarCacheExpiry.get(t);if(e<r)return this.avatarCache.get(t)}return null}}const y=new v;export{y as f};
