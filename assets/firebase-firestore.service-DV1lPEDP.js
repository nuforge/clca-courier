import{bL as f,aU as c,bM as U,aY as b,l as s,bN as D,aT as u,aS as h,bO as C,bP as y,aW as g,aX as $,bQ as W,aV as w,ah as L,bR as A,bS as _,bT as O,bU as x}from"./index-DsgKP-0L.js";import{bo as Z}from"./index-DsgKP-0L.js";import{f as m}from"./firebase-auth.service-03qodj7b.js";function N(d){if(d==null)return{};if(Array.isArray(d))return d.filter(e=>e!=null).map(e=>typeof e=="object"?N(e):e);if(typeof d=="object"){const e={};for(const[t,r]of Object.entries(d))r!=null&&(typeof r=="object"?e[t]=N(r):e[t]=r);return e}return d}function H(d,e){const t=[];for(const r of e)(!(r in d)||d[r]===void 0||d[r]===null)&&t.push(`Missing required field: ${r}`);return{isValid:t.length===0,errors:t,cleanedData:N(d)}}function B(d,e=[]){const t=N(d);return e.length>0?H(t,e):{isValid:!0,errors:[],cleanedData:t}}const M=["id","contentId","version","timestamp","userId","changeType"];function j(d){return B(d,M)}class P{config;constructor(e={}){this.config={maxHistoryEntries:50,enableAutoArchival:!0,archiveAfterDays:90,enableCompression:!1,...e}}async updateWithVersioning(e,t,r,i){try{const n=f(c,e,t),o=await U(n);if(!o.exists())throw new Error(`Document not found: ${t}`);const a=o.data(),l=a.versioning?.currentVersion||0,p=l+1,I=this.calculateChanges(a,r),R=this.cleanUndefinedValues(r),T={...a,...R,versioning:{currentVersion:p,currentHash:this.calculateHash({...a,...R}),parentVersion:l,branch:i.branch||"main"},updatedAt:new Date().toISOString(),updatedBy:i.userId},E={id:`${t}_${p}`,contentId:t,version:p,timestamp:b(),userId:i.userId,changeType:this.determineChangeType(I),changes:I,snapshot:this.cleanUndefinedValues(T),hash:T.versioning.currentHash,comment:i.comment||"",branch:i.branch||"main"},S=j(E);if(!S.isValid)throw s.error("Versioning data validation failed:",S.errors),new Error(`Validation failed: ${S.errors.join(", ")}`);const F=f(c,e,t,"history",p.toString());await D(F,S.cleanedData);const V=N(T);await D(n,V,{merge:!0}),s.info(`Content versioning: Updated ${e}/${t} to version ${p}`)}catch(n){throw s.error("Content versioning update failed:",n),n}}async getHistory(e,t,r=this.config.maxHistoryEntries||50){try{const i=u(c,e,t,"history"),n=h(i,C("version","desc"),y(r)),o=await g(n),a=[];return o.forEach(l=>{const p=l.data();a.push(p)}),a}catch(i){throw s.error("Failed to get content history:",i),i}}async restoreVersion(e,t,r,i,n=""){try{const o=f(c,e,t,"history",r.toString()),a=await U(o);if(!a.exists())throw new Error(`Version ${r} not found for ${t}`);const p=a.data().snapshot;return await this.updateWithVersioning(e,t,p,{userId:i,comment:n||`Restored to version ${r}`}),s.info(`Content versioning: Restored ${e}/${t} to version ${r}`),p}catch(o){throw s.error("Content version restoration failed:",o),o}}calculateChanges(e,t){const r={};for(const[i,n]of Object.entries(t)){const o=e[i];this.hasChanged(o,n)&&(r[i]=[o,n])}return r}hasChanged(e,t){return e===t?!1:e==null||t==null?e!==t:typeof e=="object"&&typeof t=="object"?JSON.stringify(e)!==JSON.stringify(t):!0}cleanUndefinedValues(e){if(e==null)return e;if(Array.isArray(e))return e.filter(r=>r!==void 0).map(r=>typeof r=="object"&&r!==null?this.cleanUndefinedValues(r):r);if(typeof e=="object"){const t={};for(const[r,i]of Object.entries(e))i!==void 0&&(typeof i=="object"&&i!==null?t[r]=this.cleanUndefinedValues(i):t[r]=i);return t}return e}calculateHash(e){const{versioning:t,updatedAt:r,updatedBy:i,...n}=e,o=JSON.stringify(n,Object.keys(n).sort());let a=0;for(let l=0;l<o.length;l++){const p=o.charCodeAt(l);a=(a<<5)-a+p,a=a&a}return Math.abs(a).toString(36)}determineChangeType(e){if("isPublished"in e){const[,t]=e.isPublished;return t?"publish":"archive"}return"update"}}new P;class z{core;COLLECTION="newsletters";constructor(e){this.core=new P(e)}async updateNewsletterWithVersioning(e,t,r){try{await this.core.updateWithVersioning(this.COLLECTION,e,t,r),s.info(`Newsletter versioning: Updated newsletter ${e} to new version`)}catch(i){throw s.error("Newsletter versioning update failed:",i),i}}async getNewsletterHistory(e,t=50){try{return await this.core.getHistory(this.COLLECTION,e,t)}catch(r){throw s.error("Failed to get newsletter history:",r),r}}async restoreNewsletterVersion(e,t,r,i=""){try{const n=await this.core.restoreVersion(this.COLLECTION,e,t,r,i);return s.info(`Newsletter versioning: Restored newsletter ${e} to version ${t}`),n}catch(n){throw s.error("Newsletter version restoration failed:",n),n}}async getNewsletterVersionCount(e){try{return(await this.getNewsletterHistory(e,1e3)).length}catch(t){return s.error("Failed to get newsletter version count:",t),0}}async hasVersioning(e){try{return(await this.getNewsletterHistory(e,1)).length>0}catch(t){return s.error("Failed to check newsletter versioning status:",t),!1}}}const v=new z,q=async(d,e,t)=>{const r=N(e);return s.debug("🛡️ SAFE WRITE:",{original:e,cleaned:r}),t?D(d,r,t):D(d,r)},Q=async(d,e)=>{const t=N(e);return s.debug("🛡️ SAFE ADD:",{original:e,cleaned:t}),$(d,t)};class Y{COLLECTIONS={NEWSLETTERS:"newsletters",USER_CONTENT:"userContent",USER_PROFILES:"userProfiles",NEWSLETTER_ISSUES:"newsletterIssues",APPROVAL_QUEUE:"approvalQueue"};async saveNewsletterMetadata(e){try{const t=m.getCurrentUser();if(!t)throw new Error("User must be authenticated to save newsletter metadata");const r=await Q(u(c,this.COLLECTIONS.NEWSLETTERS),{...e,createdAt:b(),updatedAt:b(),createdBy:t.uid,updatedBy:t.uid});return s.success("Newsletter metadata saved:",r.id),r.id}catch(t){throw s.error("Error saving newsletter metadata:",t),t}}async getNewsletterMetadata(e){try{const t=f(c,this.COLLECTIONS.NEWSLETTERS,e),r=await U(t);return r.exists()?{id:r.id,...r.data()}:null}catch(t){throw s.error("Error getting newsletter metadata:",t),t}}async updateNewsletterMetadata(e,t){try{const r=m.getCurrentUser();if(!r)throw new Error("User must be authenticated to update newsletter metadata");const i=f(c,this.COLLECTIONS.NEWSLETTERS,e);await q(i,{...t,updatedAt:b(),updatedBy:r.uid},{merge:!0}),s.success("Newsletter metadata updated/created:",e)}catch(r){throw s.error("Error updating newsletter metadata:",r),r}}async deleteNewsletterMetadata(e){try{if(!m.getCurrentUser())throw new Error("User must be authenticated to delete newsletter metadata");const r=f(c,this.COLLECTIONS.NEWSLETTERS,e);await W(r),s.success("Newsletter metadata deleted:",e)}catch(t){throw s.error("Error deleting newsletter metadata:",t),t}}async upsertNewsletterMetadata(e){try{const t=m.getCurrentUser();if(!t)throw new Error("User must be authenticated to save newsletter metadata");const r=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("filename","==",e.filename),y(1)),i=await g(r);if(!i.empty){const o=i.docs[0];if(o){const a=o.id;return s.info(`Found existing newsletter with filename ${e.filename}, updating document ${a}`),await this.updateNewsletterMetadata(a,e),a}}s.info(`No existing newsletter found with filename ${e.filename}, creating new document`);const n=await $(u(c,this.COLLECTIONS.NEWSLETTERS),{...e,createdAt:b(),updatedAt:b(),createdBy:t.uid,updatedBy:t.uid});return s.success("New newsletter metadata created:",n.id),n.id}catch(t){throw s.error("Error upserting newsletter metadata:",t),t}}async findNewsletterIdByFilename(e){try{const t=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("filename","==",e),y(1)),r=await g(t);if(!r.empty){const i=r.docs[0];if(i)return i.id}return null}catch(t){return s.error(`Error finding newsletter ID by filename ${e}:`,t),null}}async getAllNewsletterMetadata(){try{s.info("Attempting to fetch newsletter metadata...");const e=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("isPublished","==",!0),y(100));s.info("Executing Firestore query with isPublished filter...");const t=await g(e);s.info(`Retrieved ${t.docs.length} published documents from Firestore`);const r=t.docs.map(i=>{const n=i.data();return{id:i.id,...n}}).sort((i,n)=>L(i.publicationDate,n.publicationDate));return s.success(`Successfully processed ${r.length} published newsletters`),r}catch(e){throw s.error("Error getting all newsletter metadata:",e),e instanceof Error&&e.message.includes("permission")&&(s.error("Permission denied - this might indicate:"),s.error("1. Firestore rules are not allowing public read access"),s.error("2. The documents do not have isPublished=true"),s.error("3. Firebase configuration is incorrect")),e}}async getAllNewslettersForAdmin(){try{s.info("Admin: Fetching ALL newsletters (including unpublished)..."),s.info("Admin: Firebase project:",c.app.options.projectId),s.info("Admin: Database:",this.COLLECTIONS.NEWSLETTERS);const e=h(u(c,this.COLLECTIONS.NEWSLETTERS),y(100)),t=await g(e);s.info(`Admin: Retrieved ${t.docs.length} total documents from Firestore`),t.docs.length>0&&s.info("Admin: Sample document IDs:",t.docs.slice(0,3).map(o=>({id:o.id,filename:o.data().filename,createdAt:o.data().createdAt})));const r=t.docs.map(o=>{const a=o.data();return{id:o.id,...a}}),i=r.filter(o=>o.isPublished===!0),n=r.filter(o=>o.isPublished!==!0);return s.info(`Admin: Loaded ${i.length} published, ${n.length} unpublished newsletters`),r}catch(e){throw s.error("Admin: Error getting all newsletters:",e),e}}async submitUserContent(e){try{const t=m.getCurrentUser();if(!t)throw new Error("User must be authenticated to submit content");const r=await $(u(c,this.COLLECTIONS.USER_CONTENT),{...e,submissionDate:b(),status:"pending",authorId:t.uid,authorName:t.displayName||"Anonymous",authorEmail:t.email||""});return s.success("User content submitted:",r.id),r.id}catch(t){throw s.error("Error submitting user content:",t),t}}async getUserContent(e){try{const t=f(c,this.COLLECTIONS.USER_CONTENT,e),r=await U(t);return r.exists()?{id:r.id,...r.data()}:null}catch(t){throw s.error("Error getting user content:",t),t}}async updateContentStatus(e,t,r){try{const i=m.getCurrentUser();if(!i)throw new Error("User must be authenticated to update content status");const n=f(c,this.COLLECTIONS.USER_CONTENT,e),o={status:t,reviewedBy:i.uid,reviewDate:new Date().toISOString()};r&&(o.reviewNotes=r),await A(n,o),s.success("Content status updated:",e,t)}catch(i){throw s.error("Error updating content status:",i),i}}async updateContentFeaturedStatus(e,t){try{if(!m.getCurrentUser())throw new Error("User must be authenticated to update featured status");const i=f(c,this.COLLECTIONS.USER_CONTENT,e);await A(i,{featured:t}),s.success("Content featured status updated:",e,t)}catch(r){throw s.error("Error updating content featured status:",r),r}}async getPendingContent(){try{try{const e=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","pending"),C("submissionDate","desc"));return(await g(e)).docs.map(r=>({id:r.id,...r.data()}))}catch(e){s.warn("Index not ready, using fallback query without ordering");const t=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","pending"));return(await g(t)).docs.map(n=>({id:n.id,...n.data()})).sort((n,o)=>L(n.submissionDate,o.submissionDate))}}catch(e){throw s.error("Error getting pending content:",e),e}}async getPublishedContent(){try{s.debug("Fetching published content...");try{const e=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","published"),C("submissionDate","desc")),t=await g(e);return s.debug(`Found ${t.size} published documents`),t.docs.map(i=>{const n={id:i.id,...i.data()};return s.debug(`Published document: ${i.id} - ${n.title} - Status: ${n.status}`),n})}catch(e){s.warn("Index not ready for published content, using fallback query",e);const t=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","published")),r=await g(t);return s.debug(`Fallback query found ${r.size} published documents`),r.docs.map(n=>({id:n.id,...n.data()})).sort((n,o)=>L(n.submissionDate,o.submissionDate))}}catch(e){throw s.error("Error getting published content:",e),e}}async getApprovedContent(){try{try{const e=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","in",["approved","published"]),C("submissionDate","desc"));return(await g(e)).docs.map(r=>({id:r.id,...r.data()}))}catch(e){s.warn("Index not ready for approved content, using fallback query");const t=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","in",["approved","published"]));return(await g(t)).docs.map(n=>({id:n.id,...n.data()})).sort((n,o)=>L(n.submissionDate,o.submissionDate))}}catch(e){throw s.error("Error getting approved content:",e),e}}convertUserContentToNewsItem(e){const t={article:"news",announcement:"announcement",event:"event",classified:"announcement",photo:"announcement"},r=_(e.submissionDate)?.toISOString()||new Date().toISOString();return{id:e.id,title:e.title,summary:e.content.substring(0,200)+(e.content.length>200?"...":""),content:e.content,author:e.authorName,date:r,category:t[e.type]||"news",featured:e.featured??!1}}async getPublishedContentAsNewsItems(){try{return(await this.getPublishedContent()).map(t=>this.convertUserContentToNewsItem(t))}catch(e){throw s.error("Error getting published content as news items:",e),e}}async getApprovedContentAsNewsItems(){try{return(await this.getPublishedContent()).map(t=>this.convertUserContentToNewsItem(t))}catch(e){throw s.error("Error getting published content as news items:",e),e}}subscribeToPublishedContent(e){const t=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","published"),C("submissionDate","desc"));return O(t,r=>{const n=r.docs.map(o=>({id:o.id,...o.data()})).map(o=>this.convertUserContentToNewsItem(o));e(n),s.debug(`Real-time update: ${n.length} published content items`)},r=>{s.error("Error in published content subscription:",r),e([])})}subscribeToApprovedContent(e){const t=h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","in",["approved","published"]),C("submissionDate","desc"));return O(t,r=>{const i=r.docs.map(o=>({id:o.id,...o.data()}));s.debug(`Subscription retrieved ${i.length} approved content items:`,i);const n=i.map(o=>this.convertUserContentToNewsItem(o));e(n),s.debug(`Real-time update: ${n.length} approved content items`)},r=>{s.error("Error in approved content subscription:",r),e([])})}async createUserProfile(e){try{const t=f(c,this.COLLECTIONS.USER_PROFILES,e.uid);await q(t,{...e,createdAt:b(),lastLoginAt:b()}),s.success("User profile created:",e.uid)}catch(t){throw s.error("Error creating user profile:",t),t}}async getUserProfile(e){try{const t=f(c,this.COLLECTIONS.USER_PROFILES,e),r=await U(t);return r.exists()?r.data():null}catch(t){throw s.error("Error getting user profile:",t),t}}async updateUserProfile(e,t){try{const r=f(c,this.COLLECTIONS.USER_PROFILES,e);await A(r,t),s.success("User profile updated:",e)}catch(r){throw s.error("Error updating user profile:",r),r}}subscribeToNewsletters(e){try{s.info("Setting up newsletter subscription...");const t=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("isPublished","==",!0),y(50));return O(t,r=>{s.info(`Newsletter subscription received ${r.docs.length} documents`);const i=r.docs.map(n=>{const o=n.data();return{id:n.id,...o}}).filter(n=>{const o=n.isPublished===!0;return o||s.debug(`Subscription filtering out unpublished newsletter: ${n.title||n.id}`),o}).sort((n,o)=>L(n.publicationDate,o.publicationDate));s.success(`Newsletter subscription processed ${i.length} published newsletters`),e(i)},r=>{s.error("Newsletter subscription error:",r),r.message.includes("permission")&&(s.error("Subscription permission denied - this might indicate:"),s.error("1. Firestore rules are not allowing public read access"),s.error("2. The documents do not have isPublished=true"),s.error("3. Firebase configuration is incorrect")),e([])})}catch(t){return s.error("Error setting up newsletter subscription:",t),()=>{}}}subscribeToNewslettersForAdmin(e){try{s.info("Setting up ADMIN newsletter subscription (including unpublished)...");const t=h(u(c,this.COLLECTIONS.NEWSLETTERS),C("createdAt","desc"),y(100));return O(t,r=>{s.info(`Admin newsletter subscription received ${r.docs.length} documents`);const i=r.docs.map(n=>{const o=n.data();return{id:n.id,...o}}).sort((n,o)=>L(n.publicationDate,o.publicationDate));s.success(`Admin newsletter subscription processed ${i.length} newsletters (including unpublished)`),e(i)},r=>{s.error("Admin newsletter subscription error:",r),r.message.includes("permission")&&s.debug("Permission denied for admin newsletter subscription"),e([])})}catch(t){return s.error("Error setting up admin newsletter subscription:",t),e([]),()=>{}}}subscribeToPendingContent(e){try{s.info("Setting up pending content subscription...");const t=h(u(c,this.COLLECTIONS.USER_CONTENT),y(50));return O(t,r=>{const i=r.docs.map(n=>({id:n.id,...n.data()})).filter(n=>n.status==="pending").sort((n,o)=>x(n.submissionDate,o.submissionDate));s.success(`Pending content subscription processed ${i.length} items`),e(i)},r=>{s.error("Pending content subscription error:",r),r.message.includes("permission")&&s.debug("Permission denied for pending content - user may not be editor"),e([])})}catch(t){return s.error("Error setting up pending content subscription:",t),e([]),()=>{}}}async searchNewsletters(e){try{if(!e||e.trim().length===0){const a=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("isPublished","==",!0),C("publicationDate","desc"),y(100));return(await g(a)).docs.map(p=>({id:p.id,...p.data()}))}const t=h(u(c,this.COLLECTIONS.NEWSLETTERS),w("isPublished","==",!0),y(200)),i=(await g(t)).docs.map(a=>({id:a.id,...a.data()})),o=e.toLowerCase().trim().split(/\s+/).filter(a=>a.length>0);return i.map(a=>{let l=0;const p=a.title.toLowerCase(),I=a.description?.toLowerCase()||"",R=a.searchableText?.toLowerCase()||"",T=a.tags.map(E=>E.toLowerCase());return o.forEach(E=>{p.includes(E)&&(l+=p===E?100:50),I.includes(E)&&(l+=20),T.some(S=>S===E)&&(l+=30),T.some(S=>S.includes(E))&&(l+=15),R.includes(E)&&(l+=10),a.season?.toLowerCase().includes(E)&&(l+=25),a.year.toString().includes(E)&&(l+=25),a.issueNumber?.toLowerCase().includes(E)&&(l+=30)}),{newsletter:a,score:l}}).filter(a=>a.score>0).sort((a,l)=>l.score-a.score).map(a=>a.newsletter)}catch(t){throw s.error("Error searching newsletters:",t),t}}async updateNewsletterWithVersioning(e,t,r="",i){try{const n=i?{uid:i}:m.getCurrentUser();if(!n)throw new Error("User must be authenticated to update newsletter with versioning");const o={...t,actions:t.actions||{canView:!0,canDownload:!0,canSearch:!!t.searchableText,hasThumbnail:!!t.thumbnailUrl}};await v.updateNewsletterWithVersioning(e,o,{comment:r,userId:n.uid,branch:"main"}),s.success("Newsletter updated with versioning:",e)}catch(n){throw s.error("Error updating newsletter with versioning:",n),n}}async getNewsletterHistory(e,t=50){try{return await v.getNewsletterHistory(e,t)}catch(r){throw s.error("Error getting newsletter history:",r),r}}async restoreNewsletterVersion(e,t,r="",i){try{const n=i?{uid:i}:m.getCurrentUser();if(!n)throw new Error("User must be authenticated to restore newsletter version");const o=await v.restoreNewsletterVersion(e,t,n.uid,r||`Restored to version ${t}`);return s.success("Newsletter restored to version:",e,t),o}catch(n){throw s.error("Error restoring newsletter version:",n),n}}async getNewsletterVersionCount(e){try{return await v.getNewsletterVersionCount(e)}catch(t){return s.error("Error getting newsletter version count:",t),0}}async hasNewsletterVersioning(e){try{return await v.hasVersioning(e)}catch(t){return s.error("Error checking newsletter versioning status:",t),!1}}async getNewsletterStats(){try{const e=new Date().getFullYear(),[t,r,i,n]=await Promise.all([g(u(c,this.COLLECTIONS.NEWSLETTERS)),g(h(u(c,this.COLLECTIONS.NEWSLETTERS),w("year","==",e),w("isPublished","==",!0))),g(h(u(c,this.COLLECTIONS.USER_CONTENT),w("status","==","pending"))),g(u(c,this.COLLECTIONS.USER_PROFILES))]);return{totalNewsletters:t.size,publishedThisYear:r.size,pendingContent:i.size,totalUsers:n.size}}catch(e){throw s.error("Error getting newsletter stats:",e),e}}}const G=new Y;export{G as default,Z as deleteField,G as firestoreService};
