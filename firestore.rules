rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    // Helper functions
    function isAuthenticated() {
      return request.auth != null;
    }
    
    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }
    
    // Get user role from their profile document
    function getUserRole(uid) {
      let userProfile = get(/databases/$(database)/documents/userProfiles/$(uid));
      return userProfile.data.role;
    }
    
    // Enhanced role hierarchy supporting new role system
    function getRoleLevel(role) {
      return role == 'reader' ? 0 :
             role == 'member' ? 0 :
             role == 'contributor' ? 1 :
             role == 'canva_contributor' ? 2 :
             role == 'editor' ? 3 :
             role == 'admin' ? 4 :
             role == 'moderator' ? 4 :
             role == 'administrator' ? 5 : 0;
    }
    
    // Check if user has required role or higher
    function hasRole(uid, requiredRole) {
      let userRole = getUserRole(uid);
      return getRoleLevel(userRole) >= getRoleLevel(requiredRole);
    }

    // Check if user can manage roles (moderator or administrator)
    function canManageRoles(uid) {
      let userRole = getUserRole(uid);
      return userRole in ['moderator', 'administrator', 'admin'];
    }

    // User profiles collection
    match /userProfiles/{userId} {
      // Users can read their own profile
      allow read: if isOwner(userId);
      
      // Moderators and administrators can read any profile
      allow read: if isAuthenticated() && canManageRoles(request.auth.uid);
      
      // Users can only create their own profile with 'member' role
      allow create: if isAuthenticated() && 
        request.auth.uid == userId && 
        request.resource.data.role in ['member', 'reader'];
      
      // Users can update their own profile but CANNOT change role, permissions, or approval status
      allow update: if isOwner(userId) && 
        !resource.data.diff(request.resource.data).affectedKeys().hasAny(['role', 'permissions', 'isApproved', 'approvedBy', 'approvalDate']);
      
      // Moderators and administrators can update role and permissions
      allow update: if isAuthenticated() && canManageRoles(request.auth.uid);
    }

    // Role assignments collection - Enhanced role system
    match /roleAssignments/{userId} {
      // Users can read their own role assignment
      allow read: if isOwner(userId);
      
      // Moderators and administrators can read any role assignment
      allow read: if isAuthenticated() && canManageRoles(request.auth.uid);
      
      // Only moderators and administrators can create/update role assignments
      allow write: if isAuthenticated() && canManageRoles(request.auth.uid);
    }

    // Role requests collection
    match /roleRequests/{requestId} {
      // Users can read their own role requests
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      
      // Moderators and administrators can read all role requests
      allow read: if isAuthenticated() && canManageRoles(request.auth.uid);
      
      // Authenticated users can create role requests for themselves
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      
      // Only moderators and administrators can update role requests (approve/reject)
      allow update: if isAuthenticated() && canManageRoles(request.auth.uid);
    }

    // Role transitions collection (audit log)
    match /roleTransitions/{transitionId} {
      // Only moderators and administrators can read role transitions
      allow read: if isAuthenticated() && canManageRoles(request.auth.uid);
      
      // Only the system (server-side) should write role transitions
      // This will be handled by Cloud Functions or admin SDK
      allow write: if false; // Prevent client-side writes
    }

    // Role configurations collection
    match /roleConfigs/{roleType} {
      // Anyone can read role configurations (for UI display)
      allow read: if true;
      
      // Only administrators can update role configurations
      allow write: if isAuthenticated() && getUserRole(request.auth.uid) == 'administrator';
    }

    // Newsletter metadata collection - PUBLIC READ FOR PUBLISHED CONTENT
    match /newsletters/{newsletterId} {
      // Allow anyone to read published newsletters (no auth required)
      allow read: if resource.data.isPublished == true;
      
      // Allow authenticated users to read ALL newsletters (including unpublished)
      allow read: if isAuthenticated();
      
      // Only allow write access if user has admin or editor role
      allow write: if isAuthenticated() && 
        getUserRole(request.auth.uid) in ['admin', 'editor'];
    }

    // User-generated content collection
    match /userContent/{contentId} {
      // Allow anyone to read published content (for news page)
      allow read: if resource.data.status == 'published';
      
      // Allow authenticated users with editor+ role to read ALL content (for admin interface)
      allow read: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
      
      // Allow authenticated users to create content (they must be the author)
      allow create: if isAuthenticated() && request.auth.uid == request.resource.data.authorId;
      
      // Allow authors to update their own content (but not status), or editors+ to update status
      // Special handling for Canva design fields and print job claiming
      allow update: if isAuthenticated() && (
        (request.auth.uid == resource.data.authorId && 
         !resource.data.diff(request.resource.data).affectedKeys().hasAny(['status', 'reviewedBy']) &&
         // Allow authors to update canvaDesign field only when status is 'pending'
         (resource.data.status == 'pending' || 
          !request.resource.data.diff(resource.data).affectedKeys().hasAny(['canvaDesign']))) ||
        hasRole(request.auth.uid, 'editor') ||
        // Allow admin/editor to update canvaDesign.status to 'exported'
        (hasRole(request.auth.uid, 'admin') && 
         resource.data.diff(request.resource.data).affectedKeys().hasOnly(['canvaDesign']) &&
         request.resource.data.canvaDesign.status == 'exported') ||
        // Allow any authenticated user to claim print jobs
        (resource.data.diff(request.resource.data).affectedKeys().hasOnly(['printJob']) &&
         resource.data.printJob.status == 'print_ready' &&
         request.resource.data.printJob.status == 'claimed' &&
         request.resource.data.printJob.claimedBy == request.auth.uid) ||
        // Allow claimed user to mark their print job as completed
        (resource.data.diff(request.resource.data).affectedKeys().hasOnly(['printJob']) &&
         resource.data.printJob.status == 'claimed' &&
         resource.data.printJob.claimedBy == request.auth.uid &&
         request.resource.data.printJob.status == 'completed')
      );
      
      // Allow editors+ to delete content
      allow delete: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
    }

    // Newsletter issues collection - Admin/Editor only
    match /newsletterIssues/{issueId} {
      allow read, write: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
    }

    // Content categories collection - Admin/Editor only
    match /contentCategories/{categoryId} {
      allow read, write: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
    }

    // Approval queue collection - Admin/Editor only
    match /approvalQueue/{queueId} {
      allow read, write: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
    }

    // Helper function to check if user has task assignment permissions
    function canManageTasks(uid) {
      let userProfile = get(/databases/$(database)/documents/userProfiles/$(uid));
      return userProfile.data.get('preferences', {}).get('taskAssignments', false) == true;
    }

    // Helper function to validate task status transitions
    function isValidTaskStatusTransition(currentStatus, newStatus) {
      return (currentStatus == 'unclaimed' && newStatus == 'claimed') ||
             (currentStatus == 'claimed' && newStatus in ['unclaimed', 'in-progress', 'completed']) ||
             (currentStatus == 'in-progress' && newStatus in ['claimed', 'completed']);
    }

    // ContentDoc collection - NEW UNIFIED CONTENT ARCHITECTURE
    match /content/{contentId} {
      // Allow anyone to read published content (public access)
      allow read: if resource.data.status == 'published';
      
      // Allow authenticated users with editor+ role to read ALL content (admin interface)
      allow read: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
      
      // Allow contributors+ to read content with tasks for volunteer workflow
      allow read: if isAuthenticated() && hasRole(request.auth.uid, 'contributor') && 
        'feat:task' in resource.data.features;
      
      // Allow authors to read their own content regardless of status
      allow read: if isAuthenticated() && request.auth.uid == resource.data.authorId;
      
      // Allow authenticated users to create content (must be the author)
      allow create: if isAuthenticated() && 
        request.auth.uid == request.resource.data.authorId &&
        request.resource.data.status in ['draft', 'published'];
      
      // Allow authors to update their own content, editors+ to change status
      allow update: if isAuthenticated() && (
        // Authors can update their own content but not change status or tasks
        (request.auth.uid == resource.data.authorId && 
         !request.resource.data.diff(resource.data).affectedKeys().hasAny(['status', 'features.feat:task'])) ||
        
        // Editors+ can update status and moderate content
        hasRole(request.auth.uid, 'editor') ||
        
        // Volunteer task management permissions
        (isValidTaskUpdate(request.auth.uid, resource.data, request.resource.data))
      );
      
      // Allow editors+ to delete content
      allow delete: if isAuthenticated() && hasRole(request.auth.uid, 'editor');
    }

    // Helper function to validate task updates
    function isValidTaskUpdate(uid, currentData, newData) {
      let affectedKeys = currentData.diff(newData).affectedKeys();
      
      // Only allow task-related changes
      if (!affectedKeys.hasOnly(['features.feat:task', 'timestamps.updated'])) {
        return false;
      }
      
      // Check if user can manage tasks
      if (!canManageTasks(uid)) {
        return false;
      }
      
      let currentTask = currentData.features.get('feat:task', null);
      let newTask = newData.features.get('feat:task', null);
      
      // Task must exist
      if (currentTask == null || newTask == null) {
        return false;
      }
      
      // Administrators and moderators can make any task changes
      if (canManageRoles(uid)) {
        return true;
      }
      
      // Contributors can only make specific changes
      return isValidVolunteerTaskUpdate(uid, currentTask, newTask);
    }

    // Helper function to validate volunteer task updates
    function isValidVolunteerTaskUpdate(uid, currentTask, newTask) {
      // Check valid status transition
      if (!isValidTaskStatusTransition(currentTask.status, newTask.status)) {
        return false;
      }
      
      // Case 1: Claiming an unclaimed task
      if (currentTask.status == 'unclaimed' && newTask.status == 'claimed') {
        return newTask.assignedTo == uid &&
               newTask.category == currentTask.category &&
               newTask.priority == currentTask.priority &&
               newTask.estimatedTime == currentTask.estimatedTime;
      }
      
      // Case 2: Assigned user updating their own task
      if (currentTask.assignedTo == uid) {
        // Can update status but not reassign to someone else
        return newTask.assignedTo == uid &&
               newTask.category == currentTask.category &&
               newTask.priority == currentTask.priority &&
               newTask.estimatedTime == currentTask.estimatedTime;
      }
      
      // Case 3: Releasing a claimed task (unclaim)
      if (currentTask.status == 'claimed' && newTask.status == 'unclaimed' && currentTask.assignedTo == uid) {
        return !('assignedTo' in newTask) || newTask.assignedTo == null;
      }
      
      return false;
    }

    // App configuration collection - Public read for templates, admin write only
    match /app/{configId} {
      // Allow anyone to read app configuration (for public template access)
      allow read: if true;
      
      // Only allow admins to write app configuration
      allow write: if isAuthenticated() && hasRole(request.auth.uid, 'admin');
    }

    // Newsletter issues are now stored in the newsletters collection
    // No separate newsletter_issues collection needed

    // Generation progress collection - Any authenticated user for now
    match /generation_progress/{progressId} {
      allow read, write: if isAuthenticated();
    }
  }
}
